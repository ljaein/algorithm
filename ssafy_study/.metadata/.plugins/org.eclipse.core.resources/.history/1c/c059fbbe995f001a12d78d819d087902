package study0301;

import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class Main_17837_새로운게임2 {

	static int N, K, ans;
	static boolean isfin;
	static int[][] map;
	static List<Mal>[][] info;
	static List<Mal> list = new LinkedList<>();
	static int[] dy = { 0, 0, 0, -1, 1 };
	static int[] dx = { 0, 1, -1, 0, 0 };

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		K = sc.nextInt();
		map = new int[N][N];
		info = new List[N][N];
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				map[i][j] = sc.nextInt();
			}
		}
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				info[i][j] = new LinkedList<>();
			}
		}
		for (int i = 0; i < K; i++) {
			int y = sc.nextInt()-1;
			int x = sc.nextInt()-1;
			int d = sc.nextInt();
			Mal mal = new Mal(i, y, x, d);
			info[y][x].add(mal);
			list.add(mal);
		}
		isfin = false;
		while (!isfin || ans <= 1000) {
			turn();
			ans++;
		}
		System.out.println(ans == 1000 ? -1 : ans);

	}

	static void turn() {
		for (int i = 0; i < list.size(); i++) {
			Mal cur = list.get(i);
			int ny = cur.y + dy[cur.d];
			int nx = cur.x + dx[cur.d];

			if (ny < 0 || nx < 0 || ny >= N || nx >= N || map[ny][nx] == 2) {
				int idx = info[cur.y][cur.x].indexOf(cur);
				System.out.println("현재 방향"+cur.d);
				if (cur.d == 1 || cur.d == 3) {
					info[cur.y][cur.x].get(idx).d += 1;
					cur.d += 1;
				} else {
					System.out.println("in");
					info[cur.y][cur.x].get(idx).d -= 1;
					cur.d -= 1;
					System.out.println(cur.d);
				}
				ny = cur.y + dy[cur.d];
				nx = cur.x + dx[cur.d];
				System.out.println("바뀐 방향 "+ cur.d+"이동할 위치 "+ny+" "+nx);
				if (ny < 0 || nx < 0 || ny >= N || nx >= N || map[ny][nx] == 2) {
					System.out.println("유지");
					continue; // 파란색이나 바깥이면 그대로
				}
			}
			if (map[ny][nx] == 0) {
				if (info[cur.y][cur.x].size() > 1) {
					int idx = info[cur.y][cur.x].indexOf(cur);
					for (int j = idx; j < info[cur.y][cur.x].size(); j++) {
						info[ny][nx].add(info[cur.y][cur.x].remove(j));
					}
				} else {
					info[ny][nx].add(info[cur.y][cur.x].remove(0));
//					for (int k = 0; k < info[ny][nx].size(); k++) {
//						System.out.println(info[ny][nx].get(k));
//					}
				}
				System.out.println(cur.y+" "+cur.x+" -> "+ny+" "+nx);
				cur.y = ny;
				cur.x = nx;
				if (info[ny][nx].size() >= 4) {
					isfin = true;
					return;
				}
			}else if (map[ny][nx] == 1) {
				if (info[cur.y][cur.x].size() > 1) {
					int idx = info[cur.y][cur.x].indexOf(cur);
					for (int j = info[cur.y][cur.x].size() - 1; j >= idx; j--) {
						info[ny][nx].add(info[cur.y][cur.x].remove(j));
//						for (int k = 0; k < info[ny][nx].size(); k++) {
//							System.out.println(info[ny][nx].get(k));
//						}
					}
				} else {
					info[ny][nx].add(info[cur.y][cur.x].remove(0));
				}
				System.out.println(cur.y+" "+cur.x+" -> "+ny+" "+nx);
				cur.y = ny;
				cur.x = nx;
				if (info[ny][nx].size() >= 4) {
					isfin = true;
					return;
				}
			}
		}
	}

	static class Mal {
		int n, y, x, d;

		public Mal(int n, int y, int x, int d) {
			super();
			this.n = n;
			this.y = y;
			this.x = x;
			this.d = d;
		}

		@Override
		public String toString() {
			return "Mal [n=" + n + ", y=" + y + ", x=" + x + ", d=" + d + "]";
		}

	}

}
